## 工厂方法
### 定义
定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。

### 类图
![工厂方法类图](https://github.com/yetote/StudyNote/blob/master/res/工厂方法类图.png)
### 代码
- 产品抽象类
```

public abstract class Produce {

    public void price(){
        System.out.println("价格");
    }


    public abstract void type();
}
```
- 工厂抽象类
```
public abstract class Creator {
    public abstract <T extends Produce> T createProduce(Class<T> c);
}
```
- 产品实现类
```
public class Drink extends Produce {
    @Override
    public void type() {
        System.out.println("产品为饮料");
    }
}
```

```
public class Food extends Produce {
    @Override
    public void type() {
        System.out.println("产品为食品");
    }
}
```
- 工厂实现类
```
public class CreateFactory extends Creator {
    @Override
    public <T extends Produce> T createProduce(Class<T> c) {
        Produce produce = null;
        try {
            produce = (T) Class.forName(c.getName()).newInstance();

        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return (T) produce;
    }
}
```
- 场景类

```
public static void main(String[] args) {
    Creator creator = new CreateFactory();

    Produce food = creator.createProduce(Food.class);
    food.type();

    Produce drink = creator.createProduce(Drink.class);
    drink.type();
}
```
- 输出
```
产品为食品
产品为饮料
```
### 简单工厂模式  
简单工厂模式简化了工厂模块，去掉了工厂抽象类。并且通过静态方法简化了实例化过程。相比原设计，简单工厂扩展性稍弱，但是可读性较强，在实际场景中，使用频率也较高。
