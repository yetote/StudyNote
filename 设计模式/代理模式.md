### 代理模式
#### 定义
为其他对象提供一种代理以控制对这个对象的访问。
#### 类图
![代理模式类图](https://s1.ax1x.com/2020/06/09/t5e72q.png)
#### 代码
- 抽象主题角色
```
public interface Subject {
    void request();
}
```
- 具体主题角色
```
public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("do some thing");
    }
}
```
- 代理主题角色
```
public class Proxy implements Subject {
    private Subject subject = null;

    public Proxy(Subject subject) {
        this.subject = subject;
    }

    private void before() {
        System.out.println("before");
    }

    private void after() {
        System.out.println("after");
    }

    @Override
    public void request() {
        before();
        subject.request();
        after();
    }
}
```
- 场景
```
public static void main(String[] args) {
    Subject subject=new RealSubject();
    Subject proxy=new Proxy(subject);
    proxy.request();
}
```
### 优点
- 职责清晰
- 高扩展性
### 扩展
#### 普通代理
普通代理要求只能访问代理角色，不能访问真实角色
##### 类图
![普通代理类图](https://s1.ax1x.com/2020/06/10/toW4u4.png)
##### 代码
- 抽象主题角色
```
public interface Subject {
    void doSomething();
    void doAnything();
}
```
- 真实主题角色
```
public class RealSubject implements Subject {

    @Override
    public void doSomething() {
        System.out.println("do some thing");
    }

    @Override
    public void doAnything() {
        System.out.println("do any thing");
    }
}
```
- 代理类
```
public class Proxy implements Subject {
    private Subject subject = null;

    public Proxy() {
        subject = new RealSubject();
    }

    @Override
    public void doSomething() {
        subject.doSomething();
    }

    @Override
    public void doAnything() {
        subject.doAnything();
    }
}
```
- 场景类
```
public static void main(String[] args) {
    Subject proxy = new Proxy();
    proxy.doSomething();
    proxy.doAnything();
}
```
我们在场景类中看到我们并没有初始化真实主题类，而是通过初始化代理类间接地初始化真实场景类。
#### 强制代理
强制代理需要从真实角色去访问代理角色,不允许直接访问代理角色。
##### 类图
![强制代理类图](https://s1.ax1x.com/2020/06/10/toW4u4.png)
##### 代码
- 抽象主题角色 
```
public interface Subject {
    void doSomething();
    void doAnything();
    Subject getSubject();
}
```
- 真实主题角色
```
public class RealSubject implements Subject {

    Proxy proxy = null;

    public RealSubject() {
    }

    @Override
    public void doSomething() {
        if (isProxy()) {
            System.out.println("do something");
        } else {
            System.out.println("请设置代理");
        }
    }

    @Override
    public void doAnything() {
        if (isProxy()) {
            System.out.println("do anything");
        } else {
            System.out.println("请设置代理");
        }
    }

    @Override
    public Subject getSubject() {
        this.proxy = new Proxy(this);
        return this.proxy;
    }

    private boolean isProxy() {
        return proxy != null;
    }
}
```
- 代理类
```
public class Proxy implements Subject {
    Subject subject = null;

    public Proxy(Subject subject) {
        this.subject = subject;
    }

    @Override
    public void doSomething() {
        subject.doSomething();
    }

    @Override
    public void doAnything() {
        subject.doAnything();
    }

    @Override
    public Subject getSubject() {
        return this;
    }
}
```
- 场景类
```
public static void main(String[] args) {
        Subject subject = new RealSubject();
        Subject proxy = subject.getSubject();
        proxy.doSomething();
        proxy.doAnything();

}
```
#### 动态代理
![动态代理类图.png](https://s1.ax1x.com/2020/06/11/tbudiV.png)
##### 代码
- 抽象主题类
```
public interface Subject {
    void doSomething(String str);
}

```
- 真实主题类
```
public class RealSubject implements Subject {
    @Override
    public void doSomething(String str) {
        System.out.println("do something  ---------->" + str);
    }
}
```
- 动态代理Handler类
```
public class MyInvocationHandler implements InvocationHandler {
    Class clz = null;
    Object obj = null;

    public MyInvocationHandler(Object obj) {
        this.obj = obj;
    }

    @Override
    public Object invoke(Object o, Method method, Object[] args) throws Throwable {

        return method.invoke(obj, args);
    }
}
```
- 动态代理类
```
public class DynamicProxy<T> {

    public static <T> T newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h) {
        if (true){
            new BeforeAdvice().exec();
        }
        return (T) Proxy.newProxyInstance(loader,interfaces,h);
    }
}
```
- 通知接口
```
public interface IAdvice{
    void exec();
}
```
- 通知接口实现
```
public class BeforeAdvice implements IAdvice {
    @Override
    public void exec() {
        System.out.println("我是前置通知，我被执行了");
    }
}
```
- 场景
```
public static void main(String[] args) {
    Subject subject = new RealSubject();
    InvocationHandler handler = newMyInvocationHandler(subject);
    Subject proxy = DynamicProxy.newProxyInstanc(subject.getClass().getClassLoader(),subject.getClass().getInterfaces(), handler);
    proxy.doSomething("finish");
}
```