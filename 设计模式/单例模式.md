## 单例模式
### 定义
确保某一个类只有一个对象，并且自行实例化，并向整个系统提供这个实例化对象。
### 优点
- 节约资源
- 避免资源被多重占用
### 缺点 
- 扩展困难
- 部分情况下影响测试
### 适用场景
当系统中要求某个对象仅能存在一个实例并且需要全局使用，则需要使用单例模式。例如：生成唯一序列号、资源读写、工具类等。
### 代码
#### 饿汉式
```
public class Singleton {
    private static Singleton singleton = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return singleton;
    }
    
}
```
这段代码很简单，主要是通过设置一个静态的实例，然后通过私有的构造方法初始化实例。这也是单例模式的两个特征。
#### 懒汉式
```
private static Singleton singleton = null;

private Singleton() {
}

public static Singleton getInstance() {
    if (singleton == null) {
            singleton = new Singleton();
    }
    return singleton;
}
```
这种方式被称为懒汉式单例，区别在于懒汉式只有在使用的时候才会初始化，而饿汉式则会在一开始就实例化，这点区别会导致**饿汉式线程安全**，懒汉式线程不安全。
#### 双重检查式
```
private volatile static Singleton singleton = null;
private Singleton() {
}
public static Singleton getInstance() {
    if (singleton == null) {
        synchronized (Singleton.class) {
            if (singleton == null) {
                singleton = new Singleton();
            }
        }
    }
    return singleton;
}
```
使用volatile限制指令重排，synchronized用于加锁保证线程安全。第二个判空条件用于获取锁之后初始化操作，第一个判空条件用于检少非同步状态下获取锁的资源消耗。
#### 静态内部类
```
Singleton() {
}

static class SingletonHelper {
    private static final Singleton INSTANCE = newSingleton();
}

public static Singleton getInstance() {
    return SingletonHelper.INSTANCE;
}
```
在静态内部类中初始化单例实例并保证线程安全。和普通的饿汉式区别在于Singleton被加载时并没有进行初始化，只有执行getInstance才会装载SingletonHelper去实例化。