### 原型模式
#### 定义
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
#### 类图
![原型模式类图](https://s1.ax1x.com/2020/06/17/NAXMhn.png)
#### 代码
```
public PrototypeClass clone() {
    PrototypeClass prototypeClass = null;
    try {
        prototypeClass = (PrototypeClass)super.clone();
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return prototypeClass;
}
```
就是实现Cloneable接口后重写Object类的clone方法就可以了
#### 优点
- 性能好
- 避免构造函数的约束
#### 注意事项
- 在使用clone拷贝对象时，构造函数并不会被执行。这一点很好理解: clone的原理就是内存拷贝，所以不存在初始化过程。
#### 深拷贝与浅拷贝
##### 浅拷贝
- 原型类
```
public class PrototypeClass implements Cloneable {
    private ArrayList<String> arrayList = new ArrayList<>();

    @Override
    public PrototypeClass clone() {
        PrototypeClass prototypeClass = null;
        try {
            prototypeClass = (PrototypeClass) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return prototypeClass;
    }

    public void setValue(String val) {
        arrayList.add(val);
    }

    public ArrayList<String> getArrayList() {
        return arrayList;
    }
}
```
- 场景类
```
public static void main(String[] args) {

    PrototypeClass prototypeClass = newPrototypeClass();
    prototypeClass.setValue("a");
    PrototypeClass prototypeClassClone =prototypeClass.clone();
    prototypeClassClone.setValue("b");
    System.out.println("--------------------原始表--------------------");
    System.out.println(Arrays.toStrin(prototypeClass.getArrayList().toArray()));
    System.out.println("--------------------clone列表--------------------");
    System.out.println(Arrays.toStrin(prototypeClassClone.getArrayList().toArray());
}
```
- 输出
```
--------------------原始列表--------------------
[a, b]
--------------------clone后列表--------------------
[a, b]
```
在经过clone操作后，clone类和原类共用一个列表。出现这种情况的原因是因为Object类提供的clone方法只拷贝对象本身，对于对象内部的数组和引用对象都不拷贝。这种拷贝方法会导致多个拷贝对象共用一个私有成员，造成数据脏读。
##### 深拷贝
- 原型类
```
@Override
public PrototypeClass clone() {
    PrototypeClass prototypeClass = null;
    try {
        prototypeClass = (PrototypeClass)super.clone();
        prototypeClass.arrayList =(ArrayList<String>) this.arrayList.clone();
    } catch (CloneNotSupportedException e) {
        e.printStackTrace();
    }
    return prototypeClass;
}
```
在clone方法中，我们不单单对本身进行了拷贝，我们对类本身的私有成员也进行了拷贝。
- 输出
```
--------------------原始列表--------------------
[a]
--------------------clone后列表--------------------
[a, b]
```
输出结果也发生了变化，浅拷贝变成了深拷贝。
#### final与clone()
final与clone方法是互相冲突的，如果一个变量被声明为final变量，那么就无法调用他的clone方法。