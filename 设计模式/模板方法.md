### 模板模式
#### 定义
定义一个操作中的算法框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
#### 类图
![模板方法类图](https://github.com/yetote/StudyNote/blob/master/设计模式/res/模板方法类图.png)
#### 代码
- 模板抽象类
```
public abstract class AbstractMould {
    protected abstract void doSomething();

    protected abstract void doAnything();

    public void templateMethod() {
        this.doSomething();
        this.doAnything();
    }
}
```
- 实现类
```
public class ConcreteClass1 extends AbstractMould {
    @Override
    protected void doSomething() {
        System.out.println("1 do something");
    }

    @Override
    protected void doAnything() {
        System.out.println("1 do anything");

    }
}
```
```
public class ConcreteClass2 extends AbstractMould {
    @Override
    protected void doSomething() {
        System.out.println("2 do something");
    }

    @Override
    protected void doAnything() {
        System.out.println("2 do anything");

    }
}

```
- 场景类
```
public static void main(String[] args) {
    AbstractMould c1 = new ConcreteClass1();
    AbstractMould c2 = new ConcreteClass2();
    c1.templateMethod();
    c2.templateMethod();
}
```
- 输出
```
1 do something
1 do anything
2 do something
2 do anything
```
#### 优点
- 封装不变部分，扩展可变部分
- 提取公共代码，便于维护
- 行为由父类控制，子类实现
#### 扩展
- 钩子方法
抽象模板
```
protected abstract void hook();

protected boolean isHook() {
    return true;
}
```
实现类1
```
@Override
protected void hook() {
    System.out.println("1的钩子");
}
@Override
protected boolean isHook() {
    return false;
}
```
实现类2
```
@Override
protected void hook() {
    System.out.println("2的钩子");
}
@Override
protected boolean isHook() {
    return false;
}
```
输出
```
1 do something
1 do anything
2 do something
2的钩子
2 do anything

```
钩子方法就是在抽象类中声名一个抽象方法，之后由子类去实现这个抽象方法。这样就可以实现由子类去改变父类的行为。