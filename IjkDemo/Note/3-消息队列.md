### 消息队列
在进行prepare流程之前，先了解下ijkplayer内部的消息队列机制
先来看下IjkMediaPlayer_native_setup方法
- IjkMediaPlayer_native_setup
该方法位于ijkplayer_jni.c中
```
static void
IjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this) {
    ...
    //初始化,该方法中初始化了ijkplayer
    IjkMediaPlayer *mp = ijkmp_android_create(message_loop);
    ...
}

```
这里将message_loop方法传递到ijkmp_android_create中，注意，这个时候并没有去执行message_loop函数。我们跟一下ijkmp_android_create方法
- ijkmp_android_create  
该方法位于ijkplayer_android.c中
```
IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*))
{
    ...
    //这里继续初始化,ijkmp_create初始完成之后会返回IjkMediaPlayer指针
    IjkMediaPlayer *mp = ijkmp_create(msg_loop);
    ...
    return mp;
}
```
这个函数将message_loop函数指针传递到了ijkmp_create中
- ijkmp_create   
该方法位于ijkplayer.c中
```
IjkMediaPlayer *ijkmp_create(int (*msg_loop)(void *)) {
    ...
    mp->msg_loop = msg_loop;
    ...
}
```
这个方法把message_loop函数指针赋值给了ijkplayer中的msg_loop。
到这里(ijkplayer的)初始化过程就结束了，初始化时并未调用message_loop函数，只是将函数指针传递到了ijkplayer中的msg_loop属性。
### 调用
那么这个方法在哪里调用了呢？答案是prepare流程的ijkmp_prepare_async_l方法
- ijkmp_prepare_async_l   
  该方法位于ijkplayer.c中
```
static int ijkmp_prepare_async_l(IjkMediaPlayer *mp) {
    ...
    mp->msg_thread = SDL_CreateThreadEx(&mp->_msg_thread, ijkmp_msg_loop, mp, "ff_msg_loop");
    ...
}
```
这里创建了一个线程(ijkmp_msg_loop)
- ijkmp_msg_loop
```
static int ijkmp_msg_loop(void *arg) {
    IjkMediaPlayer *mp = arg;
    int ret = mp->msg_loop(arg);
    return ret;
}
```
在这里我们看到了他执行了message_loop方法，参数为IJKMediaPlayer对象
好了到了这里，我们可以看message_loop的代码了
### 具体代码
- message_loop
```
static int message_loop(void *arg) {
    ...
    IjkMediaPlayer *mp = (IjkMediaPlayer *) arg;
    message_loop_n(env, mp);
    ...
}
```
- message_loop_n
```
static void message_loop_n(JNIEnv *env, IjkMediaPlayer *mp) {
    jobject weak_thiz = (jobject) ijkmp_get_weak_thiz(mp);

    while (1) {
        AVMessage msg;
1、     int retval = ijkmp_get_msg(mp, &msg, 1);
2、     switch (msg.what) {
            case FFP_MSG_FLUSH:
                post_event(env, weak_thiz, MEDIA_NOP, 0, 0);
                break;
            case FFP_MSG_ERROR:
                post_event(env, weak_thiz, MEDIA_ERROR, MEDIA_ERROR_IJK_PLAYER, msg.arg1);
                break;
            case FFP_MSG_PREPARED:
                post_event(env, weak_thiz, MEDIA_PREPARED, 0, 0);
                break;
            case FFP_MSG_COMPLETED:
                post_event(env, weak_thiz, MEDIA_PLAYBACK_COMPLETE, 0, 0);
                break;
            case FFP_MSG_VIDEO_SIZE_CHANGED:
                post_event(env, weak_thiz, MEDIA_SET_VIDEO_SIZE, msg.arg1, msg.arg2);
                break;
            case FFP_MSG_SAR_CHANGED:
                post_event(env, weak_thiz, MEDIA_SET_VIDEO_SAR, msg.arg1, msg.arg2);
                break;
            case FFP_MSG_VIDEO_RENDERING_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_VIDEO_RENDERING_START, 0);
                break;
            case FFP_MSG_AUDIO_RENDERING_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_AUDIO_RENDERING_START, 0);
                break;
            case FFP_MSG_VIDEO_ROTATION_CHANGED:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_VIDEO_ROTATION_CHANGED, msg.arg1);
                break;
            case FFP_MSG_AUDIO_DECODED_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_AUDIO_DECODED_START, 0);
                break;
            case FFP_MSG_VIDEO_DECODED_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_VIDEO_DECODED_START, 0);
                break;
            case FFP_MSG_OPEN_INPUT:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_OPEN_INPUT, 0);
                break;
            case FFP_MSG_FIND_STREAM_INFO:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_FIND_STREAM_INFO, 0);
                break;
            case FFP_MSG_COMPONENT_OPEN:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_COMPONENT_OPEN, 0);
                break;
            case FFP_MSG_BUFFERING_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_BUFFERING_START, msg.arg1);
                break;
            case FFP_MSG_BUFFERING_END:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_BUFFERING_END, msg.arg1);
                break;
            case FFP_MSG_BUFFERING_UPDATE:
                post_event(env, weak_thiz, MEDIA_BUFFERING_UPDATE, msg.arg1, msg.arg2);
                break;
            case FFP_MSG_BUFFERING_BYTES_UPDATE:
                break;
            case FFP_MSG_BUFFERING_TIME_UPDATE:
                break;
            case FFP_MSG_SEEK_COMPLETE:
                post_event(env, weak_thiz, MEDIA_SEEK_COMPLETE, 0, 0);
                break;
            case FFP_MSG_ACCURATE_SEEK_COMPLETE:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_MEDIA_ACCURATE_SEEK_COMPLETE,msg.arg1);
                break;
            case FFP_MSG_PLAYBACK_STATE_CHANGED:
                break;
            case FFP_MSG_TIMED_TEXT:
                if (msg.obj) {
                    jstring text = (*env)->NewStringUTF(env, (char *) msg.obj);
                    post_event2(env, weak_thiz, MEDIA_TIMED_TEXT, 0, 0, text);
                    J4A_DeleteLocalRef__p(env, &text);
                } else {
                    post_event2(env, weak_thiz, MEDIA_TIMED_TEXT, 0, 0, NULL);
                }
                break;
            case FFP_MSG_GET_IMG_STATE:
                if (msg.obj) {
                    jstring file_name = (*env)->NewStringUTF(env, (char *) msg.obj);
                    post_event2(env, weak_thiz, MEDIA_GET_IMG_STATE, msg.arg1, msg.arg2, file_name);
                    J4A_DeleteLocalRef__p(env, &file_name);
                } else {
                    post_event2(env, weak_thiz, MEDIA_GET_IMG_STATE, msg.arg1, msg.arg2, NULL);
                }
                break;
            case FFP_MSG_VIDEO_SEEK_RENDERING_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_VIDEO_SEEK_RENDERING_START,msg.arg1);
                break;
            case FFP_MSG_AUDIO_SEEK_RENDERING_START:
                post_event(env, weak_thiz, MEDIA_INFO, MEDIA_INFO_AUDIO_SEEK_RENDERING_START,msg.arg1);
                break;
            default:
                break;
        }
        msg_free_res(&msg);
    }
}
```
代码很长，并不难，而且这段代码很熟悉。简单来说就是通过不同的状态去发送不同的消息。什么消息呢？发送给谁呢？怎么发送呢？先不着急，
代码中我分为了两部分，我们先来看一下第一部分ijkmp_get_msg方法
#### ijkmp_get_msg
- ijkmp_get_msg方法
    该方法位于ijkplayer.c中
```
int ijkmp_get_msg(IjkMediaPlayer *mp, AVMessage *msg, int block) {
    while (1) {
        int continue_wait_next_msg = 0;
        int retval = msg_queue_get(&mp->ffplayer->msg_queue, msg, block);
        if (retval <= 0)
            return retval;

        switch (msg->what) {
            case FFP_MSG_PREPARED:
                if (mp->mp_state == MP_STATE_ASYNC_PREPARING) {
                    ijkmp_change_state_l(mp, MP_STATE_PREPARED);
                } 
                if (!mp->ffplayer->start_on_prepared) {
                    ijkmp_change_state_l(mp, MP_STATE_PAUSED);
                }
                break;

            case FFP_MSG_COMPLETED:
                mp->restart = 1;
                mp->restart_from_beginning = 1;
                ijkmp_change_state_l(mp, MP_STATE_COMPLETED);
                break;
            case FFP_MSG_SEEK_COMPLETE:
                mp->seek_req = 0;
                mp->seek_msec = 0;
                break;
            case FFP_REQ_START:
                continue_wait_next_msg = 1;
                if (0 == ikjmp_chkst_start_l(mp->mp_state)) {
                    if (mp->restart) {
                        if (mp->restart_from_beginning) {
                            retval = ffp_start_from_l(mp->ffplayer, 0);
                            if (retval == 0)
                                ijkmp_change_state_l(mp, MP_STATE_STARTED);
                        } else {
                            retval = ffp_start_l(mp->ffplayer);
                            if (retval == 0)
                                ijkmp_change_state_l(mp, MP_STATE_STARTED);
                        }
                        mp->restart = 0;
                        mp->restart_from_beginning = 0;
                    } else {
                        retval = ffp_start_l(mp->ffplayer);
                        if (retval == 0)
                            ijkmp_change_state_l(mp, MP_STATE_STARTED);
                    }
                }
                break;

            case FFP_REQ_PAUSE:
                continue_wait_next_msg = 1;
                if (0 == ikjmp_chkst_pause_l(mp->mp_state)) {
                    int pause_ret = ffp_pause_l(mp->ffplayer);
                    if (pause_ret == 0)
                        ijkmp_change_state_l(mp, MP_STATE_PAUSED);
                }
                break;

            case FFP_REQ_SEEK:
                continue_wait_next_msg = 1;
                if (0 == ikjmp_chkst_seek_l(mp->mp_state)) {
                    mp->restart_from_beginning = 0;
                }
                break;
        }
        if (continue_wait_next_msg) {
            msg_free_res(msg);
            continue;
        }
        return retval;
    }
    return -1;
}
```
我们来看一下msg_queue_get方法
- msg_queue_get
该方法位于ijkplayer/ff_ffmsg_queue.h中
```
inline static int msg_queue_get(MessageQueue *q, AVMessage *msg, int block)
{
    AVMessage *msg1;
    for (;;) {
        if (q->abort_request) {
            ret = -1;
            break;
        }

        msg1 = q->first_msg;
        if (msg1) {
            q->first_msg = msg1->next;
            if (!q->first_msg)
                q->last_msg = NULL;
            q->nb_messages--;
            *msg = *msg1;
            msg1->obj = NULL;
#ifdef FFP_MERGE
            av_free(msg1);
#else
            msg1->next = q->recycle_msg;
            q->recycle_msg = msg1;
#endif
            ret = 1;
            break;
        } else if (!block) {
            ret = 0;
            break;
        } else {
            SDL_CondWait(q->cond, q->mutex);
        }
    }
    return ret;
}
```
该方法是内联方法，终止请求(abort_request)返回-1,这段代码并不复杂，就是从messagequeue中取数据，取到的数据赋值给第二个参数，那么MessageQueue中的数据是什么时候放入的呢？
##### MessageQueue数据的放入
根据get我们能想到放入的方法应该为set(结果是put，差不多)，那么msg_queue_put方法在什么时候调用呢？
msg_queue_start方法会调用，