### 入口方法
```
ijkMediaPlayer = new IjkMediaPlayer();
```
### 结构
- tv/danmaku/ijk/media/player/IjkPlayer.java
    - IjkMediaPlayer()
    - IjkMediaPlayer(IjkLibLoader libLoader)
    - initPlayer(IjkLibLoader libLoader)
        - loadLibrariesOnce(IjkLibLoader libLoader)
        - initNativeOnce()
        - native_setup(Object IjkMediaPlayer_this)
- ijkmedia/ijkplayer/android/ijkplayer_jni.c
    - JNI_OnLoad    
- ijkmedia/ijkplayer/ijkplayer.c    
    - ijkmp_global_init()
    - ijkmp_global_set_inject_callback(inject_callback)
    - ijkmp_create(int (*msg_loop)(void *))
- ijkmedia/ijkplayer/ff_ffplay.c
    - ffp_global_init()
- ijkmedia/ijkplayer/ijkavformat/allformats.c
    - ijkav_register_all(void)
    - #define IJK_REGISTER_PROTOCOL(x)   
- ijkmedia/ijkplayer/ijkavformat/ijkmediadatasource.c
    - struct ijkimp_ff_ijkmediadatasource_protocol
- ijkmedia/ijkplayer/ffmpeg_api_jni.c
    - FFmpegApi_global_init
- ijkmedia/ijkplayer/android/ijkplayer_android.c
    - ijkmp_android_create
- ijkmedia/ijkplayer/ff_ffplay_def.h
### 分析
#### Java
- 当我们通过new初始化之后会调用他的无参构造方法
```
public IjkMediaPlayer() {
        //无参的构造方法会调用一个有参(loadlib)的构造方法
        this(sLocalLibLoader);
    }
```
```sLocalLibLoader```是一个接口,通过回调加载so库
- 之后查看调用的这个构造方法
```
public IjkMediaPlayer(IjkLibLoader libLoader) {
        //调用init方法,并传递libload接口
        initPlayer(libLoader);
    }
```
- 接下来调用他的initPlayer方法
    ```
         private void initPlayer(IjkLibLoader libLoader) {
        //调用静态方法,将接口传递给它,用于加载c++库
        loadLibrariesOnce(libLoader);
        //用于初始化native方法
        initNativeOnce();
        //声明一个loop
        Looper looper;
        //通过各种方法设置这个loop
        if ((looper = Looper.myLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else if ((looper = Looper.getMainLooper()) != null) {
            mEventHandler = new EventHandler(this, looper);
        } else {
            mEventHandler = null;
        }
        //一个native方法,用于初始化ijkplayer
        native_setup(new WeakReference<IjkMediaPlayer>(this));
    }
    ```
    这个方法时正式的初始化方法,在其中加载了so库,设置了looper,调用了```native```的初始化与```setup```方法
    - **loadLibrariesOnce**方法用于加载so库
    ```
    public static void loadLibrariesOnce(IjkLibLoader libLoader) {
        synchronized (IjkMediaPlayer.class) {
            //通过这里判断c++库是否已加载
            if (!mIsLibLoaded) {
                //接口为null时重设下接口
                if (libLoader == null)
                    libLoader = sLocalLibLoader;
                //通过接口回调去加载这三个so
                libLoader.loadLibrary("ijkffmpeg");
                libLoader.loadLibrary("ijksdl");
                libLoader.loadLibrary("ijkplayer");
                //加载完毕
                mIsLibLoaded = true;
            }
        }
    }
    ```
    由于```initNativeOnce```方法最终调用的native方法是一个空方法,而设置looper这段代码没什么难度,所以我们直接分析```native_setup```方法
    - **native_setup**  

    这个方法给native层传了一个**ijkplayer**的弱引用(跟MediaPlayer学的),所以解析请查看native:2

#### Native

- JNI_OnLoad
    该方法会在**java**层调用```System.loadLibrary```时调用
    ```
    JNIEXPORT jint JNI_OnLoad(JavaVM *vm,void *reserved){
        JNIEnv *env = NULL;
        g_jvm = vm;
        if ((*vm)->GetEnv(vm,(void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        return -1;
        }
        assert(env!= NULL);
        pthread_mutex_init(&g_clazz.mutex, NULL );
        // FindClass returns LocalReference
        IJK_FIND_JAVA_CLASS(env, g_clazz.clazz, JNI_CLASS_IJKPLAYER);
        (*env)->RegisterNatives(env, g_clazz.clazz, g_methods,NELEM(g_methods));
        ijkmp_global_init();1
        ijkmp_global_set_inject_callback(inject_callback);2
        FFmpegApi_global_init(env);3
        return JNI_VERSION_1_4;
    }
    ```
    我们看到了其中执行了三个方法,```ijkmp_global_init```,```ijkmp_global_set_inject_callback```,```FFmpegApi_global_init ```
    - **ijkmp_global_init**  
     这个方法位于**ijkmedia/ijkplayer/ijkplayer.c** 中
    ```
    void ijkmp_global_init() {
    ffp_global_init();
    }
    ```
    这个方法在**ijkmedia/ijkplayer/ff_ffplay.c**中
    ```
    void ffp_global_init(){
        if (g_ffmpeg_global_inited)
            return;

        ALOGD("ijkmediaplayer version : %s", ijkmp_version());
        /* register all codecs, demux and protocols */
        avcodec_register_all();
        #if CONFIG_AVDEVICE
            avdevice_register_all();
        #endif
        #if CONFIG_AVFILTER
            avfilter_register_all();
        #endif
        av_register_all();

        ijkav_register_all();

        avformat_network_init();

        av_lockmgr_register(lockmgr);
        av_log_set_callback(ffp_log_callback_brief);

        av_init_packet(&flush_pkt);
        flush_pkt.data = (uint8_t *)&flush_pkt;

        g_ffmpeg_global_inited = true;
    }

    ```
    除了注册**ffmpeg**中的组件外,还调用```ijkav_register_all```方法, 这个方法定义在**ijkplayer/ijkavformat/allformats.c**中,
    ```
    void ijkav_register_all(void){
        static int initialized;

        if (initialized)
            return;
        initialized = 1;

        av_register_all();

        /* protocols */
        av_log(NULL, AV_LOG_INFO, "===== custom modules begin =====\n");
        #ifdef __ANDROID__
            IJK_REGISTER_PROTOCOL(ijkmediadatasource);
        #endif
        IJK_REGISTER_PROTOCOL(ijkio);
        IJK_REGISTER_PROTOCOL(async);
        IJK_REGISTER_PROTOCOL(ijklongurl);
        IJK_REGISTER_PROTOCOL(ijktcphook);
        IJK_REGISTER_PROTOCOL(ijkhttphook);
        IJK_REGISTER_PROTOCOL(ijksegment);
        /* demuxers */
        IJK_REGISTER_DEMUXER(ijklivehook);
        av_log(NULL, AV_LOG_INFO, "===== custom modules end =====\n");
    }
    ```
    在这里发现如果是**Android**的话,会调用 ```IJK_REGISTER_PROTOCOL```这个宏定义
    ```
    #define IJK_REGISTER_PROTOCOL(x)                                        \
        {                                                                   \
            extern URLProtocol ijkimp_ff_##x##_protocol;                        \
            int ijkav_register_##x##_protocol(URLProtocol *protocol, int protocol_size);\
            ijkav_register_##x##_protocol(&ijkimp_ff_##x##_protocol, sizeof(URLProtocol));  \
        }
    ```
    走到这里似乎走不通了,因为通过```export```可以看出来**ijkplayer**应该是修改了**ffmpeg**的```URLProtocol```类,反向思考下,我们通过```IJK_REGISTER_PROTOCOL(ijkmediadatasource)```可以确认是是用到了```ijkmediadatasource```这个类(c文件),我们在同目录下查看**ijkmediadatasource.c**发现
    ```
    URLProtocol ijkimp_ff_ijkmediadatasource_protocol = {
        .name                = "ijkmediadatasource",
        .url_open2           = ijkmds_open,
        .url_read            = ijkmds_read,
        .url_seek            = ijkmds_seek,
        .url_close           = ijkmds_close,
        .priv_data_size      = sizeof(Context),
        .priv_data_class     = &ijkmediadatasource_context_class,
    };
    ```
    这里是将```URLProtocol```中的函数指针重新指向该文件中定义的函数指针,包括打开方式,读取方式,seek,关闭,等等(因为剩下两个我也不知道是干啥的)  
    好了,到了这里,我们跳出**allformat.c**文件,回到**ff_ffplay.c**中的```ffp_global_init```方法,然后我们知道了```ijkav_register_all```是将```URLProtocol```中的一些函数指针重指向了```ijkplayer```中定义的函数指针,接下来我们跳```出ffp_global_init```方法,然后我们回到中间商**ijkplayer.c**中的```ijkmp_global_init```方法,然后我们在回到**ijkplayer_jni.c**中的```JNI_OnLoad```方法发现```ijkmp_global_init```我们已经阅读完毕,接下来阅读```ijkmp_global_set_inject_callback```方法,
    - **ijkmp_global_set_inject_callback**  
    这个函数从名字上可以猜测出是用来设置回调的,就是不知道是c内部回调还是从c回调到java的,
    ```
    ijkmp_global_set_inject_callback(inject_callback);
    ```
    这这里有一个参数,这个参数是一个函数指针,
    函数声明为
    ```
    static int inject_callback(void *opaque, int type, void *data, size_t data_size);
    ```
    由于未使用,暂时忽略掉函数定义
    接下来我们继续跟踪ijkmp_global_set_inject_callback方法,该方法定义在**ijkmedia/ijkplayer/ijkplayer.c**中
    ```
    void ijkmp_global_set_inject_callback(ijk_inject_callback cb) {
        ffp_global_set_inject_callback(cb);
    }
    ```
    继续跳转到ff_ffplay.c中
    ```
    void ffp_global_set_inject_callback(ijk_inject_callback cb)
    {
        s_inject_callback = cb;
    }
    ```
    这里我们将ijkplayer_jni中的函数指针赋予给ff_ffplayer.c中的s_inject_callback
    到了这里,ijkmp_global_set_inject_callback的作用就是将函数指针从ijkplayer_jni传递到ff_ffplayer.c
    - FFmpegApi_global_init   
    这个函数是JNI_OnLoad中的最后一个执行的方法,首先跟踪到ijkmedia/ijkplayer/ffmpeg_api_jni.c中,这个文件只有一个方法FFmpegApi_global_init

    ```
        static JNINativeMethod g_methods[] = {
            {"av_base64_encode", "([B)Ljava/lang/String;", (void *) FFmpegApi_av_base64_encode},
        };
        int FFmpegApi_global_init(JNIEnv *env){
            int ret = 0;

            IJK_FIND_JAVA_CLASS(env, g_clazz.clazz, JNI_CLASS_FFMPEG_API);
            (*env)->RegisterNatives(env, g_clazz.clazz, g_methods, NELEM(g_methods));
            return ret;
        }
    ```  
    这里注册了一个FFmpegApi_av_base64_encode的方法,这个方法通过java层的av_base64_encode调用,在java层的ffmpeg/FFmpegApi.java中
    ok,到这里JNI_OnLoad的流程已经走完,总结下OnLoad中进行了什么操作,首先,初始化了ffmpeg中的设置并重定向了URLProtocol中的函数指针,然后将jni中的函数指针传递到了ff_ffplay.c中,最后注册了一个jni方法
- set_up
    我们通过jni映射发现set_up对应的jni方法为IjkMediaPlayer_native_setup
    ```
    static void IjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this) {
        //初始化,该方法中初始化了ijkplayer
        IjkMediaPlayer *mp = ijkmp_android_create(message_loop);

        //判断是否正常初始化
        JNI_CHECK_GOTO(mp, env, "java/lang/OutOfMemoryError","mpjni: native_setup: ijkmp_create() failed", LABEL_RETURN);

        jni_set_media_player(env, thiz, mp);
        ijkmp_set_weak_thiz(mp, (*env)->NewGlobalRef(env, weak_this));
        ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));
        ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));
        ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback,ijkmp_get_weak_thiz(mp));

        LABEL_RETURN:
        ijkmp_dec_ref_p(&mp);
    }

    ```
    首先通过ijkmp_android_create创建了一个IjkMediaPlayer
    - ijkmp_android_create
        首先,我们先跟踪这个方法到ijkmedia/ijkplayer/android/ijkplayer_android.c中
        ```
        IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){
            //这里继续初始化,ijkmp_create初始完成之后会返回IjkMediaPlayer指针
            IjkMediaPlayer *mp = ijkmp_create(msg_loop);
            if (!mp)
                goto fail;
            //创建ffplay的显示surface
            mp->ffplayer->vout = SDL_VoutAndroid_CreateForAndroidSurface();
            if (!mp->ffplayer->vout)
                goto fail;
            //在这里初始化了一些pipeline的设置
            mp->ffplayer->pipeline = ffpipeline_create_from_android(mp->ffplayer);
            if (!mp->ffplayer->pipeline)
                goto fail;
            //这里设置视频了输出设备
            ffpipeline_set_vout(mp->ffplayer->pipeline, mp->ffplayer->vout);

            return mp;

        fail:
            ijkmp_dec_ref_p(&mp);
            return NULL;
        }
        ```
        然后我们看到ijkplayer继续通过ijkmp_create进行初始化,我们继续跟踪到ijkplayer.c中
        - ijkmp_create
        ```
        IjkMediaPlayer *ijkmp_create(int (*msg_loop)(void *)) {
            //通过mallocz分配ijkplayer
            IjkMediaPlayer *mp = (IjkMediaPlayer *) mallocz(sizeof(IjkMediaPlayer));
            if (!mp)
                //失败的话会回到goto去销毁
                goto fail;

            mp->ffplayer = ffp_create();
            if (!mp->ffplayer)
                goto fail;
            //将参数中的函数指针传递给了ijkplayer的loop属性
            mp->msg_loop = msg_loop;
            //为ijkplayer中的引用计数+1
            ijkmp_inc_ref(mp);
            pthread_mutex_init(&mp->mutex, NULL);

            return mp;

            fail:
            ijkmp_destroy_p(&mp);
            return NULL;
        }
        ```
        这里我们发现ijkplayer通过mallocz分配了内存,这个mallocz我没有找到关于它的定义,不过在ffmpeg中有av_mallocz,它是分配内存并将内存的值设为0,估计认为他们是一样的,接下来就是初始化IjkMediaPlayer中对应的属性,第一个就是ffplayer
        - ffp_create
            跟踪FFPlayer这个结构体,发现它定义在ijkmedia/ijkplayer/ff_ffplay_def
            .h中,是一个结构体,由于属性较多,所以就不贴代码了,用到哪个属性再分析哪个属性
