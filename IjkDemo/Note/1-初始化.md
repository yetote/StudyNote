### 入口方法
```
ijkMediaPlayer = new IjkMediaPlayer();
```
### 分析
#### Java
- 当我们通过new初始化之后会调用他的无参构造方法
```
public IjkMediaPlayer() {
    //无参的构造方法会调用一个有参(loadlib)的构造方法
    this(sLocalLibLoader);
}
```
```sLocalLibLoader```是一个接口，通过回调加载**so**库
- 之后查看调用的这个构造方法
```
public IjkMediaPlayer(IjkLibLoader libLoader) {
    //调用init方法，并传递libload接口
    initPlayer(libLoader);
}
```
- 接下来调用他的initPlayer方法
```
private void initPlayer(IjkLibLoader libLoader) {
    //调用静态方法，将接口传递给它，用于加载c++库
    loadLibrariesOnce(libLoader);
    //用于初始化native方法
    initNativeOnce();
    //声明一个loop
    Looper looper;
    //通过各种方法设置这个loop
    if ((looper = Looper.myLooper()) != null) {
        mEventHandler = new EventHandler(this, looper);
    } else if ((looper = Looper.getMainLooper()) != null) {
        mEventHandler = new EventHandler(this, looper);
    } else {
        mEventHandler = null;
    }
    //一个native方法,用于初始化ijkplayer
    native_setup(new WeakReference<IjkMediaPlayer>(this));
}
```
这个方法时正式的初始化方法，在其中加载了so库，设置了looper，调用了```native```的初始化与```setup```方法
- **loadLibrariesOnce**方法用于加载so库
```
public static void loadLibrariesOnce(IjkLibLoader libLoader) {
    synchronized (IjkMediaPlayer.class) {
        //通过这里判断c++库是否已加载
        if (!mIsLibLoaded) {
            //接口为null时重设下接口
            if (libLoader == null)
                libLoader = sLocalLibLoader;
            //通过接口回调去加载这三个so
            libLoader.loadLibrary("ijkffmpeg");
            libLoader.loadLibrary("ijksdl");
            libLoader.loadLibrary("ijkplayer");
            //加载完毕
            mIsLibLoaded = true;
        }
    }
}
```
由于```initNativeOnce```方法最终调用的native方法是一个空方法，而设置looper这段代码没什么难度，所以我们直接分析```native_setup```方法
- **native_setup**  
这个方法给native层传了一个**ijkplayer**的弱引用(跟MediaPlayer学的)

#### Native

- JNI_OnLoad
该方法会在**java**层调用```System.loadLibrary```时调用
```
JNIEXPORT jint JNI_OnLoad(JavaVM *vm,void *reserved){
    JNIEnv *env = NULL;
    g_jvm = vm;
    if ((*vm)->GetEnv(vm,(void**) &env, JNI_VERSION_1_4) != JNI_OK) {
    return -1;
    }
    assert(env!= NULL);
    pthread_mutex_init(&g_clazz.mutex, NULL );
    // FindClass returns LocalReference
    IJK_FIND_JAVA_CLASS(env, g_clazz.clazz, JNI_CLASS_IJKPLAYER);
    (*env)->RegisterNatives(env, g_clazz.clazz, g_methods,NELEM(g_methods));
    ijkmp_global_init();1
    ijkmp_global_set_inject_callback(inject_callback);2
    FFmpegApi_global_init(env);3
    return JNI_VERSION_1_4;
}
```  
我们看到了其中执行了三个方法，```ijkmp_global_init```、```ijkmp_global_set_inject_callback```、```FFmpegApi_global_init ```  
- **ijkmp_global_init**  
这个方法位于**ijkmedia/ijkplayer/ijkplayer.c** 中
```
void ijkmp_global_init() {
    ffp_global_init();
}
``` 
- ffp_global_init  
这个方法在**ijkmedia/ijkplayer/ff_ffplay.c**中
```
void ffp_global_init(){
    if (g_ffmpeg_global_inited)
        return;
    ALOGD("ijkmediaplayer version :%s"ijkmp_version()) ;
    /* register all codecs, demux andprotocols */
    avcodec_register_all();
    #if CONFIG_AVDEVICE
        avdevice_register_all();
    #endif
    #if CONFIG_AVFILTER
        avfilter_register_all();
    #endif
    av_register_all();
    ijkav_register_all();
    avformat_network_init();
    av_lockmgr_register(lockmgr);
    av_log_set_callback(ffp_log_callback_brief;
    av_init_packet(&flush_pkt);
    flush_pkt.data = (uint8_t *)&flush_pkt;
    g_ffmpeg_global_inited = true;
}
```
除了注册**ffmpeg**中的组件外，还```ijkav_register_all```方法
- ijkav_register_all  
这个方法定**ijkplayer/ijkavformat/allformats.c**中，
```
void ijkav_register_all(void){
    static int initialized
    if (initialized)
        return;
    initialized = 1
    av_register_all()
    /* protocols */
    av_log(NULL, AV_LOG_INFO, "===== customodules begin =====\n");
    #ifdef __ANDROID__
        IJK_REGISTER_PROTOC(ijkmediadatasource);
    #endif
    IJK_REGISTER_PROTOCOL(ijkio);
    IJK_REGISTER_PROTOCOL(async);
    IJK_REGISTER_PROTOCOL(ijklongurl);
    IJK_REGISTER_PROTOCOL(ijktcphook);
    IJK_REGISTER_PROTOCOL(ijkhttphook);
    IJK_REGISTER_PROTOCOL(ijksegment);
    /* demuxers */
    IJK_REGISTER_DEMUXER(ijklivehook);
    av_log(NULL, AV_LOG_INFO, "===== customodules end =====\n");
}
```
在这里发现如果是**Android**的话，会调```IJK_REGISTER_PROTOCOL```这个宏定义
```
#define IJK_REGISTER_PROTOCOL(x)                                      \
    {                                                                 \
        extern URLProtocoijkimp_ff_##x##_protocol;                      \
        int ijkav_register_##x##_protoc(URLProtocol *protocol, inprotocol_size);\
        ijkav_register_##x##_protocolijkimp_ff_##x##_protocol, size(URLProtocol));  \
    }
```
走到这里似乎走不通了，因为通过```export```可以来**ijkplayer**应该是修改了**ffmpeg**中的```URLProtocol```类，反向思考下，我们```IJK_REGISTER_PROTOCOL(ijkmediadatasource)```可以确认是是用到了```ijkmediadatasource```这(c文件)，我们在同目录下**ijkmediadatasource.c**发现
```
URLProtocoijkimp_ff_ijkmediadatasource_protocol = {
    .name                "ijkmediadatasource",
    .url_open2           = ijkmds_open,
    .url_read            = ijkmds_read,
    .url_seek            = ijkmds_seek,
    .url_close           = ijkmds_close,
    .priv_data_size      = sizeof(Context),
    .priv_data_class     =ijkmediadatasource_context_class,
};
```
这里是将```URLProtocol```中的属性初始化为对应数指针，包括打开方式，读取方式，seek，关闭，等等(因下两个我也不知道是干啥的)   
好了，到了这里，我们跳出**allformat.c**文件，回到**ff_ffplay.c**中的```ffp_global_init```方法  
然后我们知道了```ijkav_register_all```是将```URLProtocol```中属性初始化为```ijkplayer```中相对应的函数指针，接下来我们跳出```ffp_global_init```方法，然后我们回到中间商**ijkplayer.c**中的```ijkmp_global_init```方法，然后我们在回到**ijkplayer_jni.c**中的```JNI_OnLoad```方法发现```ijkmp_global_init```我们已经阅读完毕，接下来阅读```ijkmp_global_set_inject_callback```方法，
- **ijkmp_global_set_inject_callback**  
这个函数从名字上可以猜测出是用来设置回调的，就是不知道是**c**内部回调还是从**c**回调到**java**的，
```
ijkmp_global_set_inject_callback(inject_callback);
```
这这里有一个参数，这个参数是一个函数指针，函数声明为
```
static int inject_callback(void *opaque, int type, void *data, size_t data_size);
```
由于未使用,暂时忽略掉函数定义
接下来我们继续跟```ijkmp_global_set_inject_callback```方法，该方法义在**ijkmedia/ijkplayer/ijkplayer.c**中
```
void ijkmp_global_set_inject_callbac(ijk_inject_callback cb) {
    ffp_global_set_inject_callback(cb);
}
```
继续跳转到**ff_ffplay.c**中
```
void ffp_global_set_inject_callbac(ijk_inject_callback cb)
{
    s_inject_callback = cb;
}
```
这里我们将```ijkplayer_jni```中的函数指针赋予**ff_ffplayer.c**中的```s_inject_callback```
到了这里，```ijkmp_global_set_inject_callback```的用就是将函数指针从```ijkplayer_jni```传递**ff_ffplayer.c**
- FFmpegApi_global_init   
这个函数是```JNI_OnLoad```中的最后一个执行的方法，首跟踪到**ijkmedia/ijkplayer/ffmpeg_api_jni.c**中，这文件只有一个方法  
    - FFmpegApi_global_init
        ```
        static JNINativeMethod g_methods[] = {
            {"av_base64_encode", "([BLjava/lang/String;", (void *)FFmpegApi_av_base64_encode},
        };
        int FFmpegApi_global_init(JNIEnv *env){
            int ret = 0;
            IJK_FIND_JAVA_CLASS(env, g_clazz.clazz JNI_CLASS_FFMPEG_API);
            (*env)->RegisterNatives(env,g_clazz.clazz, g_methods, NELE(g_methods));
            return ret;
        }
        ```  
    这里注册了一个```FFmpegApi_av_base64_encode```的方法，这个方法通过java层的```av_base64_encode```调用，在java层的**ffmpeg/FFmpegApi.java**中  
    
到这里```JNI_OnLoad```的流程已经走完，总结下```OnLoad```中进行了什么操作，首先，初始化了**ffmpeg**中的设置并为```URLProtocol```中的属性赋予对应的函数指针，然后将**jni**中的函数指针传递到了**ff_ffplay.c**中，最后注册了一个**jni**方法
- set_up  
    我们通过jni映射发现```set_up```对应的jni方法为
    - IjkMediaPlayer_native_setup
    ```
    static void IjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this) {
        //初始化,该方法中初始化了ijkplayer
        IjkMediaPlayer *mp = ijkmp_android_create(message_loop);

        //判断是否正常初始化
        JNI_CHECK_GOTO(mp, env, "java/lang/OutOfMemoryError","mpjni: native_setup: ijkmp_create() failed", LABEL_RETURN);

        jni_set_media_player(env, thiz, mp);
        ijkmp_set_weak_thiz(mp, (*env)->NewGlobalRef(env, weak_this));
        ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));
        ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));
        ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback,ijkmp_get_weak_thiz(mp));

        LABEL_RETURN:
        ijkmp_dec_ref_p(&mp);
    }

    ```
    首先通过```ijkmp_android_create```创建了一个```IjkMediaPlayer```
    - ijkmp_android_create
        首先，我们先跟踪这个方法到**ijkmedia/ijkplayer/android/ijkplayer_android.c**中
        ```
        IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){
            //这里继续初始化，ijkmp_create初始完成之后会返回IjkMediaPlayer指针
            IjkMediaPlayer *mp = ijkmp_create(msg_loop);
            if (!mp)
                goto fail;
            //创建ffplay的显示surface
            mp->ffplayer->vout = SDL_VoutAndroid_CreateForAndroidSurface();
            if (!mp->ffplayer->vout)
                goto fail;
            //在这里初始化了一些pipeline的设置
            mp->ffplayer->pipeline = ffpipeline_create_from_android(mp->ffplayer);
            if (!mp->ffplayer->pipeline)
                goto fail;
            //这里设置视频了输出设备
            ffpipeline_set_vout(mp->ffplayer->pipeline, mp->ffplayer->vout);

            return mp;

        fail:
            ijkmp_dec_ref_p(&mp);
            return NULL;
        }
        ```
        然后我们看到```ijkplayer```继续通过```ijkmp_create```进行初始化，我们继续跟踪到**ijkplayer.c**中
        - ijkmp_create
        ```
        IjkMediaPlayer *ijkmp_create(int (*msg_loop)(void *)) {
            //通过mallocz分配ijkplayer
            IjkMediaPlayer *mp = (IjkMediaPlayer *) mallocz(sizeof(IjkMediaPlayer));
            if (!mp)
                //失败的话会回到goto去销毁
                goto fail;

            mp->ffplayer = ffp_create();
            if (!mp->ffplayer)
                goto fail;
            //将参数中的函数指针传递给了ijkplayer的loop属性
            mp->msg_loop = msg_loop;
            //为ijkplayer中的引用计数+1
            ijkmp_inc_ref(mp);
            pthread_mutex_init(&mp->mutex, NULL);

            return mp;

            fail:
            ijkmp_destroy_p(&mp);
            return NULL;
        }
        ```
        这里我们发现```ijkplayer```通过```mallocz```分配了内存，这个```mallocz```我没有找到关于它的定义，不过在```ffmpeg```中有```av_mallocz```，它是分配内存并将内存的值设为0，估计认为他们是一样的，接下来就是初始化**IjkMediaPlayer**中对应的属性
        - ffp_create  
            ```ffp_create```定义在了**ff_ffplay.c**中    
            ```
            FFPlayer *ffp_create(){
                FFPlayer* ffp = (FFPlayer*) av_mallocz(sizeof(FFPlayer));
                if (!ffp)
                    return NULL;

                msg_queue_init(&ffp->msg_queue);
                ffp->af_mutex = SDL_CreateMutex();
                ffp->vf_mutex = SDL_CreateMutex();

                ffp_reset_internal(ffp);
                ffp->av_class = &ffp_context_class;
                ffp->meta = ijkmeta_create();

                av_opt_set_defaults(ffp);

                return ffp;
            }       
            ```
            跟踪```FFPlayer```这个结构体，发现它定义在**ijkmedia/ijkplayer/ff_ffplay_def.h**中，是一个结构体，由于属性较多，所以就不贴代码了，用到哪个属性再分析哪个属性
            嗯，也是通过```mallocz```为```FFPlayer```分配内存，然后去注册内部的```msgqueue```
            - msg_queue_init  
            继续跟踪到**ijkmedia/ijkplayer/ff_ffmsg_queue.h**中
                ```
                inline static void msg_queue_init(MessageQueue *q){
                    memset(q, 0, sizeof(MessageQueue));
                    q->mutex = SDL_CreateMutex();
                    q->cond = SDL_CreateCond();
                    q->abort_request = 1;
                }
                ```
                嗯~这是一个内联函数，初始化了```MessageQueue```，然后通过```SDL```方法创建了互斥锁与互斥条件，最后设置了队列的```abort_request```(应该翻译为中止请求)为1(可能为bool值)，后续确定，这个方法对```ffplayer```的```msgqueue```进行了初始化  
            接下来也是通过```SDL```创建```ffplayer```中的互斥锁和互斥条件，然后调用```ffp_reset_internal```方法  
                - ffp_reset_internal  
                  该方法定义在了**ff_ffplay_def.h**中，也是一个内联方法，由于函数体太长，所以就不贴代码了，这个方法中对**ffplayer**中的一些属性进行了初始化  
    
            接下来是为```av_class```赋值，```ffp_context_class```是一个```AVClass```结构体常量，
            ```
            const AVClass ffp_context_class = {
                .class_name       = "FFPlayer",
                .item_name        = ffp_context_to_name,
                .option           = ffp_context_options,
                .version          = LIBAVUTIL_VERSION_INT,
                .child_next       = ffp_context_child_next,
                .child_class_next = ffp_context_child_class_next,
            };
            ```
            接下来是为```meta```赋值  
            - ijkmeta_create  
                该方法定义在**ijkmedia/ijkplayer/ijkmate.c**中
                ```
                IjkMediaMeta *ijkmeta_create(){
                    IjkMediaMeta *meta = (IjkMediaMeta *)calloc(1, sizeof(IjkMediaMeta));
                    if (!meta)
                        return NULL;

                    meta->mutex = SDL_CreateMutex();
                    if (!meta->mutex)
                        goto fail;

                    return meta;
                fail:
                    ijkmeta_destroy(meta);
                    return NULL;
                }
                ```
                使用```calloc```初始化```IjkMediaMeta```，然后初始化互斥锁，然后我们看一下```IjkMediaMeta```结构体  
                ```
                struct IjkMediaMeta {
                SDL_mutex *mutex;

                AVDictionary *dict;

                size_t children_count;
                size_t children_capacity;
                IjkMediaMeta **children;
                };
                ```
            最后通过**ffmpeg**中的```AVOption```中的```av_opt_set_defaults```将**ffp**设置默认属性，```ffp_create```方法阅读完毕，我们跳出该方法，回到**ijkplayer.c**中的```ijkmp_create```方法  
            
        之后设置```IjkMediaPlayer```中的```msg_loop```接下来是```ijkmp_inc_ref```方法
            - ijkmp_inc_ref
                这个方法的作用是将```IjkMediaPlayer```中的引用计数+1，这个方法定义在了**ijkplayer.c**中
                ```
                void ijkmp_inc_ref(IjkMediaPlayer *mp) {
                    assert(mp);
                    //为ijkplayer中的引用计数+1
                    __sync_fetch_and_add(&mp->ref_count, 1);
                }
                ```
            通过原子化操作，将```IjkMediaPlayer```中的引用计数+1
            到了这里```ijkmp_create```方法阅读完毕，我们跳出回到**ijkplayer_android.c**中继续阅读  
            
        接下来通过了```SDL_VoutAndroid_CreateForAndroidSurface```创建了```ffplayer```的视频输出设备(surface不是display)，然后通过```ffpipeline_create_from_android```创建```pipeline```  
        
        - ffpipeline_create_from_android  
            该方法定义在**ijkmedia/ijkplayer/android/pipeline/ffpipeline_android.c**中  
            ```
            IJKFF_Pipeline*ffpipeline_create_from_androi(FFPlayer *ffp){
                IJKFF_Pipeline *pipeline =ffpipeline_alloc(&g_pipeline_class sizeof(IJKFF_Pipeline_Opaque));
                if (!pipeline)
                    return pipeline;
                IJKFF_Pipeline_Opaque *opaque =pipeline->opaque;
                //设置ffplayer
                opaque->ffp                   =ffp;
                //设置surface互斥锁
                opaque->surface_mutex         =SDL_CreateMutex();
                //设置左声道音量
                opaque->left_volume           =1.0f;
                //设置右声道音量
                opaque->right_volume          =1.0f;
                if (!opaque->surface_mutex) {
                    ALOG("ffpipeline-android:createSDL_CreateMutex failed\n");
                    goto fail;
                }
                //销毁
                pipeline->func_destroy             = func_destroy;
                //视频解码器
                pipeline->func_open_video_decoder  = func_open_video_decoder;
                //音频输出
                pipeline->func_open_audio_output   = func_open_audio_output;
                //初始化视频解码器
                pipeline->func_init_video_decoder  = func_init_video_decoder;
                //配置视频解码器
                pipeline->func_config_video_decode = func_config_video_decoder;
                return pipeline;
            fail:
                ffpipeline_free_p(&pipeline);
                return NULL;
            }       
            ```
        俄罗斯套娃，第一步通过```ffpipeline_alloc```初始化```IJKFF_Pipeline```  
        - ffpipeline_alloc  
        该方法定义**ijkmedia/ijkplayer/ff_ffpipeline.c**中
        ```
        IJKFF_Pipeline *ffpipeline_alloc(SDL_Class*opaque_class, size_t opaque_size){
            IJKFF_Pipeline *pipeline =(IJKFF_Pipeline*) calloc(1, sizeo(IJKFF_Pipeline));
            if (!pipeline)
                return NULL;
            pipeline->opaque_class = opaque_class;
            pipeline->opaque       = calloc(1,opaque_size);
            if (!pipeline->opaque) {
                free(pipeline);
                return NULL;
            }
            return pipeline;
        }
        ```
        该方法通过```calloc```方法初始化```IJKFF_Pipeline```，之后设置```opaque_class```属性，并通过```calloc```方法初始化opaque属性，最后返回初始化的```IJKFF_Pipeline```  
    ```pipeline```初始化之后，开始初始化之前```calloc```方法实例化的```IJKFF_Pipeline_Opaque```  
    之后开始设置它的方法函数指针，销毁，打开视频解码器，打开音频输出，初始化视频解码器，配置视频解码器，最后返回 设置完成后的```pipeline```  
    之后再**ijkplayer_android.c**中的```ijkmp_android_create```调用了```ffpipeline_set_vout```方法
        - ffpipeline_set_vout  
        该方法也在**ffpipeline_android.c**中
        ```
            void ffpipeline_set_vou(IJKFF_Pipeline* pipeline, SDL_Vout*vout)
            {
                if (!check_ffpipeline(pipeline,__func__))
                    return;
                IJKFF_Pipeline_Opaque *opaque =pipeline->opaque;
                opaque->weak_vout = vout;
            }
        ```
        这段代码先是判断了```ffpipeline```是否成功初始化，然后将```SDL_Vout```视频输出设备与```pipeline```中的```weak_vout```关联起来
    跳出```ffpipeline_set_vout```方法回到```ijkmp_android_create```方法，该方法最后返回了设置成功的**IjkMediaPlayer**  
        接下来在**ijkplayer_jni.c**中的```IjkMediaPlayer_native_setup```方法内，去执行```jni_set_media_player```方法
        ```
        static IjkMediaPlayer *jni_set_media_player(JNIEnv *env, jobject thiz, IjkMediaPlayer *mp) {
            pthread_mutex_lock(&g_clazz.mutex);
            //获取java层的ijkmediaplayer
            IjkMediaPlayer *old = (IjkMediaPlayer *) (intptr_t) J4AC_IjkMediaPlayer__mNativeMediaPlayer__get__catchAll(
                    env, thiz);
            //如果mp存在,则其引用计数+1
            if (mp) {
                ijkmp_inc_ref(mp);
            }
            //这个方法应该是设置java层的mediaplayer为native层的mp
            J4AC_IjkMediaPlayer__mNativeMediaPlayer__set__catchAll(env, thiz, (intptr_t) mp);

            pthread_mutex_unlock(&g_clazz.mutex);

            // NOTE: ijkmp_dec_ref may block thread
            if (old != NULL) {
                //销毁ijkplayer
                ijkmp_dec_ref_p(&old);
            }
            //返回的必定是一个nullptr
            return old;
        }
        ```
        这个方法首先会去获取**java**层的**ijkmediaplayer**，然后将新的**ijkmediaplayer**传递到**java**层，销毁旧的**ijkplayer**，最后返回了一个空指针，接下来调用```ijkmp_set_weak_thiz```方法
        - ijkmp_set_weak_thiz
        这个方法定义在**ijkplayer.c**中
        ```
        void *ijkmp_set_weak_thiz(IjkMediaPlayer *mp, void *weak_thiz) {
            void *prev_weak_thiz = mp->weak_thiz;

            mp->weak_thiz = weak_thiz;

            return prev_weak_thiz;
        }
        ```
        作用很简单,就是将传递进来的弱引用与**mp**中的弱引用关联起来，最后返回之前的弱引用
    最后回到```IjkMediaPlayer_native_setup```方法，进入```ijkmp_set_inject_opaque```方法，先看这个方法的第二个参数```ijkmp_get_weak_thiz(mp)```，从函数名猜测是获取**mediaplayer**中的弱引用，我们跟踪下看看是否猜测正确，该方法定义在**ijkplayer.c**中
        ```
        void *ijkmp_get_weak_thiz(IjkMediaPlayer *mp) {
            return mp->weak_thiz;
        }
        ```
        果然正确，接下来我们查看```ijkmp_set_inject_opaque```方法
    - ijkmp_set_inject_opaque
    该方法定义在**ijkplayer.c**中
    ```
    void *ijkmp_set_inject_opaque(IjkMediaPlayer *mp, void *opaque) {
        assert(mp);

        MPTRACE("%s(%p)\n", __func__, opaque);
        void *prev_weak_thiz = ffp_set_inject_opaque(mp->ffplayer, opaque);
        MPTRACE("%s()=void\n", __func__);
        return prev_weak_thiz;
    }
    ```  
    
    调用了**ffplayer**中的```ffp_set_inject_opaque```方法，继续查看
    
    - ffp_set_inject_opaque
    ```
        void *ffp_set_inject_opaque(FFPlayer *ffp, void *opaque) {
            if (!ffp)
                return NULL;
            void *prev_weak_thiz = ffp->inject_opaque;
            ffp->inject_opaque = opaque;

            av_application_closep(&ffp->app_ctx);
            av_application_open(&ffp->app_ctx, ffp);
            ffp_set_option_int(ffp, FFP_OPT_CATEGORY_FORMAT, "ijkapplication", (int64_t)(intptr_t)
            ffp->app_ctx);

            ffp->app_ctx->func_on_app_event = app_func_event;
            return prev_weak_thiz;
        }
    ```
    仍然是设置新的```inject_opaque```，然后返回旧的，除掉**ffmpeg**中的方法(可能)后，该方法调用了```ffp_set_option_int```方法
    - ffp_set_option_int
        ```
            void ffp_set_option_int(FFPlayer *ffp, int opt_category, const char *name, int64_t value) {
                if (!ffp)
                    return;

                AVDictionary **dict = ffp_get_opt_dict(ffp, opt_category);
                av_dict_set_int(dict, name, value, 0);
            }
        ```
    这个方法设置了下**ffmpeg**中的字典，key是传递进来的```"ijkapplication"```，value是ffplay中的```app_ctx```，对应的字典是通过```ffp_get_opt_dict```获取到的  
    - ffp_get_opt_dict
    ```
    static AVDictionary **ffp_get_opt_dict(FFPlayer *ffp, int opt_category) {
        Assert(ffp);
        switch (opt_category) {
            case FFP_OPT_CATEGORY_FORMAT:
                return &ffp->format_opts;
            case FFP_OPT_CATEGORY_CODEC:
                return &ffp->codec_opts;
            case FFP_OPT_CATEGORY_SWS:
                return &ffp->sws_dict;
            case FFP_OPT_CATEGORY_PLAYER:
                return &ffp->player_opts;
            case FFP_OPT_CATEGORY_SWR:
                return &ffp->swr_opts;
            default:
                av_log(ffp, AV_LOG_ERROR, "unknown option category %d\n", opt_category);
                return NULL;
           }
    }   
    ```
    
    第二个参数是字典类型，值为```FFP_OPT_CATEGORY_FORMAT```通过该方法返回的是```format_opts```，也就是格式字典。 
    ```ffp_set_option_int```这个方法是向**ffplayer**中的```format_opts```存入了```app_ctx```，最后是初始化了**ffplayer**中的```appctx```中的```func_on_app_event```，这个属性看起来是一个函数指针。  
    
到这里```ffp_set_inject_opaque```就阅读完毕。在该方法中，重设了**ffplayer**的```inject_opaque```属性，并且关闭了就得```appctx```，打开了新的```app_ctx```，并把```appctx```加入到了**ffplayer**中的```format_opts```字典中，最后设置了下```func_on_app_event```函数指针。    
接下来```ijkmp_set_inject_opaque```也执行完毕。  
我们回到**ijkplayer_jni.c**中的```IjkMediaPlayer_native_setup```方法，去执行```ijkmp_set_ijkio_inject_opaque```方法。从名字上来看，这里应该是去执行**io**流相关操作。果然和上个方法一样，字典没变，key变成了```ijkiomanager```，value变成了```ijkio_manager_ctx```，就不具体看了。  
最后是```ijkmp_android_set_mediacodec_select_callback```，看起来是硬解相关的回调，进入看一下。  
- ijkmp_android_set_mediacodec_select_callback
该方法定义在**ijkmedia/ijkplayer/android/ijkplayer_android.c**中
    ```
    void ijkmp_android_set_mediacodec_select_callback(IjkMediaPlayer *mp, bool (*callback)(void *opaque, ijkmp_mediacodecinfo_context *mcc), void *opaque){
        if (mp && mp->ffplayer && mp->ffplayer->pipeline) {
            ffpipeline_set_mediacodec_select_callback(mp->ffplayer->pipeline, callback, opaque);
        }
    }       
    ```
    省掉了一些无用代码，去看一下```ffpipeline_set_mediacodec_select_callback```  
    - ffpipeline_set_mediacodec_select_callback
    该方法定义在**ijkmedia/ijkplayer/android/pipeline/ffpipeline_android.c**中
        ```
        void ffpipeline_set_mediacodec_select_callback(IJKFF_Pipeline* pipeline, bool (*callback)(void *opaque, ijkmp_mediacodecinfo_context *mcc), void *opaque){
            pipeline->opaque->mediacodec_select_callback        = callback;
            pipeline->opaque->mediacodec_select_callback_opaque = opaque;
        }
        ```
    这里仍然是对硬件相关进行了初始化，猜到了，跳出。  
    
当我们进行到这里，```setup```就已经执行完毕，这也表示了**ijkplayer**初始化方法阅读完毕，
### 总结  
在**IjkMediaPlaye**r的初始化方法中，先去加载了**so**库，然后初始化了**ffmpeg**，与**ijkplayer**自定义的一些**接口**、**字典**、**属性**等信息。
#### 调用流程
```
IjkMediaPlayer.java/IjkMediaPlayer
IjkMediaPlayer.java/IjkMediaPlayer(IjkLibLoader libLoader)
--->initPlayer
------->loadLibrariesOnce
------->ijkmedia/ijkplayer/android/ijkplayer_jni.c/JNI_OnLoad
----------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_global_init
--------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_global_init
----------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_global_set_inject_callback
--------------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_global_set_inject_callback
------------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_global_set_inject_callback
----------->FFmpegApi_global_init
--------------->jkmedia/ijkplayer/android/ffmpeg_api_jni.c/FFmpegApi_global_init
--->initNativeOnce
------->native_init(空方法)
--->native_setup
------->ijkmedia/ijkplayer/android/ijkplayer_jni.c/IjkMediaPlayer_native_setup
----------->ijkmedia/ijkplayer/android/ijkplayer_android.c/ijkmp_android_create
--------------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_create
--------------->ijkmedia/ijkplayer/android/pipeline/fffpipeline_android.c/ffpipeline_create_from_android
------------------->ijkmedia/ijkplayer/ffpipeline.c/ffpipeline_alloc
--------------->ijkmedia/ijkplayer/android/pipeline/fffpipeline_android.c/ffpipeline_set_vout
----------->ijkmedia/ijkplayer/android/ijkplayer_jni.c/jni_set_media_player
--------------->j4a/class/tv/danmaku/ijk/media/player/IjkMediaPlayer.c/通过#define定义的方法
----------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_set_weak_thiz
----------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_set_inject_opaque
--------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_set_inject_opaque
------------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_set_option_int
----------------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_get_opt_dict
----------->ijkmedia/ijkplayer/ijkplayer.c/ijkmp_set_ijkio_inject_opaque
--------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_set_ijkio_inject_opaque
------------------->ijkmedia/ijkplayer/ijkavformat/ijkio_manager_destroyp
------------------->ijkmedia/ijkplayer/ijkavformat/ijkio_manager_create
------------------->ijkmedia/ijkplayer/ijkavformat/ijkio_manager_set_callback
------------------->ijkmedia/ijkplayer/ff_ffplay.c/ffp_set_option_int
----------->ijkmedia/ijkplayer/android/ijkplayer_android.c/ijkmp_android_set_mediacodec_select_callback
--------------->ijkmedia/ijkplayer/android/pipeline/ffpipeline_androidc/ffpipeline_set_mediacodec_select_callback
```
