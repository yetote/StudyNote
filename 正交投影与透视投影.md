## 概念
#### 三角形扇（GL_TRIANGLE_FAN）
通过固定顶点的方式绘制三角形
#### 正交投影
投影线与投影面垂直
#### 向量
做在opengl中，向量通常有四个分量，分别是xyzw

$$ 
\begin{bmatrix}
x\\
y\\
z\\
w\\
\end{bmatrix}
$$
#### 单位矩阵

$$
\begin{bmatrix}
1&0&0&0\\
0&1&0&0\\
0&0&1&0\\
0&0&0&1\\
\end{bmatrix}
$$

#### 平移矩阵

$$
\begin{bmatrix}
1&0&0&x_{translation}\\
0&1&0&y_{translation}\\
0&0&1&z_{translation}\\
0&0&0&1\\
\end{bmatrix}
$$

将（2,2）沿x轴正方向平移3，y轴正方向平移3的运算为

$$
\begin{bmatrix}
1&0&0&3\\
0&1&0&3\\
0&0&1&0\\
0&0&0&1\\
\end{bmatrix}

\begin{bmatrix}
2\\
2\\
0\\
1\\
\end{bmatrix}
=
\begin{bmatrix}
1*2+0*2+0*0+3*1\\
0*2+1*2+0*0+3*1\\
0*2+0*2+1*0+0*1\\
0*2+0*2+0*0+1*1\\
\end{bmatrix}
$$
结果为

$$
\begin{bmatrix}
5\\
5\\
0\\
1\\
\end{bmatrix}
$$
#### 左手坐标与右手坐标
握拳，将大拇指，食指，中指自然伸开，大拇指表示X轴正方向，食指表示Y轴正方向，则中指表示的就是Z方向
#### 剪裁空间
对于xyz的值在[w,-w]之间，在这个范围之外的部分都是不可见的
#### 透视除法
gl_Position的xyz分量处理w分量，w越大，这个点距离中心就越近
#### 同质化坐标
剪裁空间的几个坐标可以映射到一个点上例如，(1,1,1,1),(2,2,2,2),(3,3,3,3)
#### 投影矩阵公式

$$
vertex_{clip}=ProjectMatrix*vertex_{eye}$$
$$
vertex_{eye}=ModelMatrix*vertex_{model}
$$
$vertex_{eye}$表示顶点与投影矩阵相乘前的位置，$vertex_{model}$表示与单位矩阵相乘前的位置
将两个公式合在一起就变成了,注意矩阵相乘是有顺序的

$$
vertex_{clip}=ProjectMatrix*ModelMatrix*vertex_{model}
$$

#### 旋转的方向
当我们判断坐标系为左手坐标系还是右手坐标系的时候，将你要旋转的轴移动到X轴正方向（大拇指的方向），卷曲的手指就是沿着这个轴的正角度的旋转的方向
旋转矩阵  **X轴**

$$
\begin{bmatrix}
1&0&0&0\\
0&cos(\alpha)&-sin(\alpha)&0\\
0&sin(\alpha)&cos(\alpha)&0\\
0&0&0&1\\
\end{bmatrix}
$$
**Y轴**

$$
\begin{bmatrix}
cos(\alpha)&0&sin(\alpha)&0\\
0&1&0&0\\
-sin(\alpha)&0&cos(\alpha)&0\\
0&0&0&1\\
\end{bmatrix}
$$
**Z轴**

$$
\begin{bmatrix}
cos(\alpha)&-sin(\alpha)&0&0\\
sin(\alpha)&cos(\alpha)&0&0\\
0&0&1&0\\
0&0&0&1\\
\end{bmatrix}
$$
## **api**
**orthoM**  
设置正交投影，参数为目标数组，结果起始矩阵偏移量，minX，maxX，minY，maxY，minZ，maxZ，当我们调用这个方法时，他应该产生正交投影矩阵

$$
\begin{bmatrix}
\frac{2}{right-left}&0&0&-\frac{right+left}{right-left}\\
0&\frac{2}{top-bottom}&0&-\frac{top+bottom}{top-bottom}\\
0&0&-\frac{2}{far-near}&-\frac{far+near}{far-near}\\
0&0&0&1\\
\end{bmatrix}
$$
注意Z轴有一个负号，这是为了翻转Z轴坐标（我没找到具体的原因，我猜测可能是因为Android使用的是左手坐标系，而opengl使用的是右手坐标系，所以需要翻转Z轴，），物体离得越远，Z坐标的负值越小  
**perspectiveM**   
设置透视投影矩阵，参数为结果矩阵，结果矩阵起始位置，视锥体角度，宽高比，近面距离，远面距离，产生的结果矩阵如下所示

$$
\begin{bmatrix}
\frac{f}{aspect}&0&0&0\\
0&f&0&0\\
0&0&-\frac{f+n}{f-n}&-\frac{2fn}{f-n}\\
0&0&-1&0\\
\end{bmatrix}
$$
注意在perspectiveM的源码中存储的矩阵方式为

$$
\begin{bmatrix}
\frac{f}{aspect}&0&0&0\\
0&f&0&0\\
0&0&-\frac{f+n}{f-n}&-1\\
0&0&-\frac{2fn}{f-n}&0\\
\end{bmatrix}
$$
这是因为在opengl中存储矩阵的方式为列存储，而Java则是行存储
**multiplyMM**  
矩阵相乘，参数为结果矩阵，结果矩阵存储位置，在左手边的矩阵(源码注解通俗易懂)，矩阵起始位置，右手边的矩阵，矩阵起始位置
**rotateM**  
旋转矩阵，参数为目标矩阵，起始位置，旋转角度，沿（xyz）轴旋转，1表示沿这个轴旋转
